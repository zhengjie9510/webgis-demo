/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as Gt,b as Xt}from"./chunk-UWTP54MD.js";import{a as kt}from"./chunk-4M7FKQYC.js";import{a as lt}from"./chunk-4XIXQUKW.js";import{a as Dt}from"./chunk-EMZN2RVW.js";import"./chunk-PNRMC4IG.js";import"./chunk-JMG4RN2X.js";import{a as qt}from"./chunk-PG5ZS3T4.js";import"./chunk-OH4CN3UY.js";import"./chunk-AAJ456AA.js";import{d as zt,i as Lt}from"./chunk-DV7DPSRL.js";import"./chunk-4FFHQQYZ.js";import{b as $,c as Ot,d as wt}from"./chunk-KCIWEUSR.js";import"./chunk-7XDW3BZW.js";import{a as P,b as N,c as Ht}from"./chunk-F33YCXD2.js";import{a as r}from"./chunk-DUBQPPQZ.js";import"./chunk-CG3JQAX7.js";import{a as Vt}from"./chunk-P3JQY4NV.js";import{a as Ut}from"./chunk-K36PKEJW.js";import"./chunk-KD2PMTHD.js";import{e as ht}from"./chunk-ZUCO5WNM.js";var te=Uint16Array.BYTES_PER_ELEMENT,mt=Int32Array.BYTES_PER_ELEMENT,Pt=Uint32Array.BYTES_PER_ELEMENT,ee=Float32Array.BYTES_PER_ELEMENT,H=Float64Array.BYTES_PER_ELEMENT;function tt(t,e,n){n=Ut(n,r);let i=t.length;for(let o=0;o<i;++o)if(n.equalsEpsilon(t[o],e,r.EPSILON12))return o;return-1}function oe(t,e){t.ellipsoid=Ht.clone(t.ellipsoid),t.rectangle=Ot.clone(t.rectangle);let n=se(t.buffer,t.relativeToCenter,t.ellipsoid,t.rectangle,t.nativeRectangle,t.exaggeration,t.exaggerationRelativeHeight,t.skirtHeight,t.includeWebMercatorT,t.negativeAltitudeExponentBias,t.negativeElevationThreshold),i=n.vertices;e.push(i.buffer);let r=n.indices;return e.push(r.buffer),{vertices:i.buffer,indices:r.buffer,numberOfAttributes:n.encoding.stride,minimumHeight:n.minimumHeight,maximumHeight:n.maximumHeight,boundingSphere3D:n.boundingSphere3D,orientedBoundingBox:n.orientedBoundingBox,occludeePointInScaledSpace:n.occludeePointInScaledSpace,encoding:n.encoding,vertexCountWithoutSkirts:n.vertexCountWithoutSkirts,indexCountWithoutSkirts:n.indexCountWithoutSkirts,westIndicesSouthToNorth:n.westIndicesSouthToNorth,southIndicesEastToWest:n.southIndicesEastToWest,eastIndicesNorthToSouth:n.eastIndicesNorthToSouth,northIndicesWestToEast:n.northIndicesWestToEast}}var u=new N,G=new P,ne=new P,ie=new P,re=new $;function se(t,e,n,i,o,a,s,l,h,c,m){let d,g,p,I,f,E;ht(i)?(d=i.west,g=i.south,p=i.east,I=i.north,f=i.width,E=i.height):(d=r.toRadians(o.west),g=r.toRadians(o.south),p=r.toRadians(o.east),I=r.toRadians(o.north),f=r.toRadians(i.width),E=r.toRadians(i.height));let T,x,S=[g,I],w=[d,p],k=Lt.eastNorthUpToFixedFrame(e,n),A=$.inverseTransformation(k,re);h&&(T=lt.geodeticLatitudeToMercatorAngle(g),x=1/(lt.geodeticLatitudeToMercatorAngle(I)-T));let M=1!==a,R=new DataView(t),b=Number.POSITIVE_INFINITY,y=Number.NEGATIVE_INFINITY,F=ne;F.x=Number.POSITIVE_INFINITY,F.y=Number.POSITIVE_INFINITY,F.z=Number.POSITIVE_INFINITY;let v=ie;v.x=Number.NEGATIVE_INFINITY,v.y=Number.NEGATIVE_INFINITY,v.z=Number.NEGATIVE_INFINITY;let B,W,_=0,C=0,j=0;for(W=0;W<4;++W){let t=_;B=R.getUint32(t,!0),t+=Pt;let e=r.toRadians(180*R.getFloat64(t,!0));t+=H,-1===tt(w,e)&&w.push(e);let n=r.toRadians(180*R.getFloat64(t,!0));t+=H,-1===tt(S,n)&&S.push(n),t+=2*H;let i=R.getInt32(t,!0);t+=mt,C+=i,i=R.getInt32(t,!0),j+=3*i,_+=B+Pt}let U=[],Y=[],V=new Array(C),D=new Array(C),O=new Array(C),L=h?new Array(C):[],Q=M?new Array(C):[],X=new Array(j),K=[],Z=[],z=[],J=[],q=0,et=0;for(_=0,W=0;W<4;++W){B=R.getUint32(_,!0),_+=Pt;let t=_,e=r.toRadians(180*R.getFloat64(_,!0));_+=H;let i=r.toRadians(180*R.getFloat64(_,!0));_+=H;let o=r.toRadians(180*R.getFloat64(_,!0)),a=.5*o;_+=H;let s=r.toRadians(180*R.getFloat64(_,!0)),l=.5*s;_+=H;let f=R.getInt32(_,!0);_+=mt;let E=R.getInt32(_,!0);_+=mt,_+=mt;let k=new Array(f);for(let H=0;H<f;++H){let t=e+R.getUint8(_++)*o;u.longitude=t;let f=i+R.getUint8(_++)*s;u.latitude=f;let E=R.getFloat32(_,!0);if(_+=ee,0!==E&&E<m&&(E*=-Math.pow(2,c)),E*=6371010,u.height=E,-1!==tt(w,t)||-1!==tt(S,f)){let t=tt(U,u,N);if(-1!==t){k[H]=Y[t];continue}U.push(N.clone(u)),Y.push(q)}k[H]=q,Math.abs(t-d)<a?K.push({index:q,cartographic:N.clone(u)}):Math.abs(t-p)<a?z.push({index:q,cartographic:N.clone(u)}):Math.abs(f-g)<l?Z.push({index:q,cartographic:N.clone(u)}):Math.abs(f-I)<l&&J.push({index:q,cartographic:N.clone(u)}),b=Math.min(E,b),y=Math.max(E,y),O[q]=E;let B=n.cartographicToCartesian(u);if(V[q]=B,h&&(L[q]=(lt.geodeticLatitudeToMercatorAngle(f)-T)*x),M){let t=n.geodeticSurfaceNormal(B);Q[q]=t}$.multiplyByPoint(A,B,G),P.minimumByComponent(G,F,F),P.maximumByComponent(G,v,v);let W=(t-d)/(p-d);W=r.clamp(W,0,1);let C=(f-g)/(I-g);C=r.clamp(C,0,1),D[q]=new wt(W,C),++q}let W=3*E;for(let n=0;n<W;++n,++et)X[et]=k[R.getUint16(_,!0)],_+=te;if(B!==_-t)throw new Vt("Invalid terrain tile.")}V.length=q,D.length=q,O.length=q,h&&(L.length=q),M&&(Q.length=q);let nt=q,it=et,rt={hMin:b,lastBorderPoint:void 0,skirtHeight:l,toENU:A,ellipsoid:n,minimum:F,maximum:v};K.sort((function(t,e){return e.cartographic.latitude-t.cartographic.latitude})),Z.sort((function(t,e){return t.cartographic.longitude-e.cartographic.longitude})),z.sort((function(t,e){return t.cartographic.latitude-e.cartographic.latitude})),J.sort((function(t,e){return e.cartographic.longitude-t.cartographic.longitude}));let ot=1e-5;if(gt(V,O,D,L,Q,X,rt,K,-ot*f,!0,-ot*E),gt(V,O,D,L,Q,X,rt,Z,-ot*E,!1),gt(V,O,D,L,Q,X,rt,z,ot*f,!0,ot*E),gt(V,O,D,L,Q,X,rt,J,ot*E,!1),K.length>0&&J.length>0){let t=K[0].index,e=nt,n=J[J.length-1].index,i=V.length-1;X.push(n,i,e,e,t,n)}C=V.length;let at,ut=zt.fromPoints(V);ht(i)&&(at=Dt.fromRectangle(i,b,y,n));let st=new Gt(n).computeHorizonCullingPointPossiblyUnderEllipsoid(e,V,b),ct=new qt(F,v,e),dt=new Xt(e,ct,rt.hMin,y,k,!1,h,M,a,s),pt=new Float32Array(C*dt.stride),It=0;for(let r=0;r<C;++r)It=dt.encode(pt,It,V[r],D[r],O[r],void 0,L[r],Q[r]);let Nt=K.map((function(t){return t.index})).reverse(),ft=Z.map((function(t){return t.index})).reverse(),Et=z.map((function(t){return t.index})).reverse(),Tt=J.map((function(t){return t.index})).reverse();return ft.unshift(Et[Et.length-1]),ft.push(Nt[0]),Tt.unshift(Nt[Nt.length-1]),Tt.push(Et[0]),{vertices:pt,indices:new Uint16Array(X),maximumHeight:y,minimumHeight:b,encoding:dt,boundingSphere3D:ut,orientedBoundingBox:at,occludeePointInScaledSpace:st,vertexCountWithoutSkirts:nt,indexCountWithoutSkirts:it,westIndicesSouthToNorth:Nt,southIndicesEastToWest:ft,eastIndicesNorthToSouth:Et,northIndicesWestToEast:Tt}}function gt(t,e,n,i,o,a,s,l,h,c,m){let d=l.length;for(let g=0;g<d;++g){let p=l[g],I=p.cartographic,f=p.index,E=t.length,T=I.longitude,x=I.latitude;x=r.clamp(x,-r.PI_OVER_TWO,r.PI_OVER_TWO);let S=I.height-s.skirtHeight;s.hMin=Math.min(s.hMin,S),N.fromRadians(T,x,S,u),c&&(u.longitude+=h),c?g===d-1?u.latitude+=m:0===g&&(u.latitude-=m):u.latitude+=h;let w=s.ellipsoid.cartographicToCartesian(u);t.push(w),e.push(S),n.push(wt.clone(n[f])),i.length>0&&i.push(i[f]),o.length>0&&o.push(o[f]),$.multiplyByPoint(s.toENU,w,G);let k=s.minimum,A=s.maximum;P.minimumByComponent(G,k,k),P.maximumByComponent(G,A,A);let M=s.lastBorderPoint;if(ht(M)){let t=M.index;a.push(t,E-1,E,E,f,t)}s.lastBorderPoint=p}}var Ae=kt(oe);export{Ae as default};