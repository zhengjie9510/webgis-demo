/**
 * @license
 * Cesium - https://github.com/CesiumGS/cesium
 * Version 1.111
 *
 * Copyright 2011-2022 Cesium Contributors
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * Columbus View (Pat. Pend.)
 *
 * Portions licensed separately.
 * See https://github.com/CesiumGS/cesium/blob/main/LICENSE.md for full licensing details.
 */
import{a as $}from"./chunk-X42YZYOT.js";import{a as Z}from"./chunk-4M7FKQYC.js";import{a as Q}from"./chunk-4XIXQUKW.js";import{a as Y,b as D,c as W,d as X}from"./chunk-F33YCXD2.js";import{a as N}from"./chunk-DUBQPPQZ.js";import"./chunk-K36PKEJW.js";import"./chunk-KD2PMTHD.js";import{d as K,e as f}from"./chunk-ZUCO5WNM.js";var q,H=K($(),1);function tt(t,e,r,n,o,a){let i=r*(1-t)+n*t,u=o*(1-t)+a*t;return i*(1-e)+u*e}function P(t,e,r,n){let o=t+e*r;return n[o]}function et(t,e,r){let n=r.nativeExtent,o=(t-n.west)/(n.east-n.west)*(r.width-1),a=(e-n.south)/(n.north-n.south)*(r.height-1),i=Math.floor(o),u=Math.floor(a);o-=i,a-=u;let s=i<r.width?i+1:i,l=u<r.height?u+1:u;u=r.height-1-u,l=r.height-1-l;let f=P(i,u,r.width,r.buffer),c=P(s,u,r.width,r.buffer),y=P(i,l,r.width,r.buffer),b=P(s,l,r.width,r.buffer),h=tt(o,a,f,c,y,b);return h=h*r.scale+r.offset,h}function J(t,e,r){for(let n=0;n<r.length;n++){let o=r[n].nativeExtent,a=new Y;if("WebMercator"===r[n].projectionType){let o=r[n].projection._ellipsoid._radii;a=new Q(new W(o.x,o.y,o.z)).project(new D(t,e,0))}else a.x=t,a.y=e;if(a.x>o.west&&a.x<o.east&&a.y>o.south&&a.y<o.north)return et(a.x,a.y,r[n])}return 0}function nt(t,e,r,n,o,a,i){if(i)return;let u=J(o.longitude,o.latitude,a);for(let s=0;s<t;++s){let t=J(o.longitude+N.toRadians(r*e[3*s]),o.latitude+N.toRadians(n*e[3*s+1]),a);e[3*s+2]+=t-u}}function rt(t,e,r,n,o,a,i,u,s){if(0===t||!f(e)||0===e.length)return;let l=new W(Math.sqrt(i.x),Math.sqrt(i.y),Math.sqrt(i.z));for(let c=0;c<t;++c){let t=3*c,i=t+1,y=t+2,b=new D;b.longitude=n.longitude+N.toRadians(u*e[t]),b.latitude=n.latitude+N.toRadians(s*e[i]),b.height=n.height+e[y];let h={};l.cartographicToCartesian(b,h),h.x-=o.x,h.y-=o.y,h.z-=o.z;let p={};if(X.multiplyByVector(a,h,p),e[t]=p.x,e[i]=p.y,e[y]=p.z,f(r)){let e=new Y(r[t],r[i],r[y]),n={};X.multiplyByVector(a,e,n),r[t]=n.x,r[i]=n.y,r[y]=n.z}}}function ot(t,e,r){for(let n=0;n<t;++n){let t=r[4*n]/65535,o=r[4*n+1]/65535,a=(r[4*n+2]-r[4*n])/65535,i=(r[4*n+3]-r[4*n+1])/65535;e[2*n]*=a,e[2*n]+=t,e[2*n+1]*=i,e[2*n+1]+=o}}function st(t,e,r,n,o,a){if(0===t||!f(r)||0===r.length)return{buffers:[],bufferViews:[],accessors:[],meshes:[],nodes:[],nodesInScene:[]};let i=[],u=[],s=[],l=[],c=[],y=[];f(e)&&(t=e.length);let b=new Uint32Array(t);if(f(e))for(let f=0;f<t;++f)b[f]=e[f];else for(let f=0;f<t;++f)b[f]=f;let h=new Blob([b],{type:"application/binary"}),p=URL.createObjectURL(h),d=t,g=r.subarray(0,3*d),m=new Blob([g],{type:"application/binary"}),w=URL.createObjectURL(m),A=Number.POSITIVE_INFINITY,I=Number.NEGATIVE_INFINITY,x=Number.POSITIVE_INFINITY,C=Number.NEGATIVE_INFINITY,v=Number.POSITIVE_INFINITY,L=Number.NEGATIVE_INFINITY;for(let f=0;f<g.length/3;f++)A=Math.min(A,g[3*f+0]),I=Math.max(I,g[3*f+0]),x=Math.min(x,g[3*f+1]),C=Math.max(C,g[3*f+1]),v=Math.min(v,g[3*f+2]),L=Math.max(L,g[3*f+2]);let O,R=n?n.subarray(0,3*d):void 0;if(f(R)){let t=new Blob([R],{type:"application/binary"});O=URL.createObjectURL(t)}let D,U=o?o.subarray(0,2*d):void 0;if(f(U)){let t=new Blob([U],{type:"application/binary"});D=URL.createObjectURL(t)}let N,_=f(a)?a.subarray(0,4*d):void 0;if(f(_)){let t=new Blob([_],{type:"application/binary"});N=URL.createObjectURL(t)}let G=0,V=0,T=0,E=0,F=0,M=G,P={};return P.POSITION=G,i.push({uri:w,byteLength:g.byteLength}),u.push({buffer:G,byteOffset:0,byteLength:g.byteLength,target:34962}),s.push({bufferView:G,byteOffset:0,componentType:5126,count:t,type:"VEC3",max:[A,x,v],min:[I,C,L]}),f(O)&&(++M,V=M,P.NORMAL=V,i.push({uri:O,byteLength:R.byteLength}),u.push({buffer:V,byteOffset:0,byteLength:R.byteLength,target:34962}),s.push({bufferView:V,byteOffset:0,componentType:5126,count:t,type:"VEC3"})),f(D)&&(++M,T=M,P.TEXCOORD_0=T,i.push({uri:D,byteLength:U.byteLength}),u.push({buffer:T,byteOffset:0,byteLength:U.byteLength,target:34962}),s.push({bufferView:T,byteOffset:0,componentType:5126,count:t,type:"VEC2"})),f(N)&&(++M,E=M,P.COLOR_0=E,i.push({uri:N,byteLength:_.byteLength}),u.push({buffer:E,byteOffset:0,byteLength:_.byteLength,target:34962}),s.push({bufferView:E,byteOffset:0,componentType:5121,normalized:!0,count:t,type:"VEC4"})),++M,F=M,i.push({uri:p,byteLength:b.byteLength}),u.push({buffer:F,byteOffset:0,byteLength:b.byteLength,target:34963}),s.push({bufferView:F,byteOffset:0,componentType:5125,count:t,type:"SCALAR"}),l.push({primitives:[{attributes:P,indices:F,material:0}]}),y.push(0),c.push({mesh:0}),{buffers:i,bufferViews:u,accessors:s,meshes:l,nodes:c,nodesInScene:y}}function it(t,e,r,n){let o=new Uint8Array(t,0,5);return o[0]==="D".charCodeAt()&&o[1]==="R".charCodeAt()&&o[2]==="A".charCodeAt()&&o[3]==="C".charCodeAt()&&o[4]==="O".charCodeAt()?ct(t,r):at(t,e,r,n)}function ct(t){let e=q,r=new e.DecoderBuffer,n=new Uint8Array(t);r.Init(n,n.length);let o,a,i=new e.Decoder,u=i.GetEncodedGeometryType(r),s=new e.MetadataQuerier;u===e.TRIANGULAR_MESH&&(o=new e.Mesh,a=i.DecodeBufferToMesh(r,o));let l={vertexCount:[0],featureCount:0};if(f(a)&&a.ok()&&0!==o.ptr){let t=o.num_faces(),r=o.num_attributes(),n=o.num_points();l.indices=new Uint32Array(3*t);let a=l.indices;l.vertexCount[0]=n,l.scale_x=1,l.scale_y=1;let u=new e.DracoInt32Array(3);for(let e=0;e<t;++e)i.GetFaceFromMesh(o,e,u),a[3*e]=u.GetValue(0),a[3*e+1]=u.GetValue(1),a[3*e+2]=u.GetValue(2);e.destroy(u);for(let c=0;c<r;++c){let t=i.GetAttribute(o,c),r=ut(e,i,o,t,n),a=t.attribute_type(),u="unknown";a===e.POSITION?u="positions":a===e.NORMAL?u="normals":a===e.COLOR?u="colors":a===e.TEX_COORD&&(u="uv0s");let y=i.GetAttributeMetadata(o,c);if(0!==y.ptr){let t=s.NumEntries(y);for(let e=0;e<t;++e){let t=s.GetEntryName(y,e);"i3s-scale_x"===t?l.scale_x=s.GetDoubleEntry(y,"i3s-scale_x"):"i3s-scale_y"===t?l.scale_y=s.GetDoubleEntry(y,"i3s-scale_y"):"i3s-attribute-type"===t&&(u=s.GetStringEntry(y,"i3s-attribute-type"))}}f(l[u])&&console.log("Attribute already exists",u),l[u]=r,"feature-index"===u&&l.featureCount++}e.destroy(o)}return e.destroy(s),e.destroy(i),l}function ut(t,e,r,n,o){let a,i=n.num_components()*o,u=[function(){},function(){a=new t.DracoInt8Array(i),e.GetAttributeInt8ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Int8Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){a=new t.DracoInt8Array(i),e.GetAttributeUInt8ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Uint8Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){a=new t.DracoInt16Array(i),e.GetAttributeInt16ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Int16Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){a=new t.DracoInt16Array(i),e.GetAttributeUInt16ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Uint16Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){a=new t.DracoInt32Array(i),e.GetAttributeInt32ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Int32Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){a=new t.DracoInt32Array(i),e.GetAttributeUInt32ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Uint32Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){},function(){},function(){a=new t.DracoFloat32Array(i),e.GetAttributeFloatForAllPoints(r,n,a)||console.error("Bad stream");let o=new Float32Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o},function(){},function(){a=new t.DracoUInt8Array(i),e.GetAttributeUInt8ForAllPoints(r,n,a)||console.error("Bad stream");let o=new Uint8Array(i);for(let t=0;t<i;++t)o[t]=a.GetValue(t);return o}][n.data_type()]();return f(a)&&t.destroy(a),u}var v={position:function(t,e,r){let n=3*t.vertexCount;return t.positions=new Float32Array(e,r,n),r+=4*n,r},normal:function(t,e,r){let n=3*t.vertexCount;return t.normals=new Float32Array(e,r,n),r+=4*n,r},uv0:function(t,e,r){let n=2*t.vertexCount;return t.uv0s=new Float32Array(e,r,n),r+=4*n,r},color:function(t,e,r){let n=4*t.vertexCount;return t.colors=new Uint8Array(e,r,n),r+=n,r},featureId:function(t,e,r){let n=t.featureCount;return r+=8*n,r},id:function(t,e,r){let n=t.featureCount;return r+=8*n,r},faceRange:function(t,e,r){let n=2*t.featureCount;return t.faceRange=new Uint32Array(e,r,n),r+=4*n,r},uvRegion:function(t,e,r){let n=4*t.vertexCount;return t["uv-region"]=new Uint16Array(e,r,n),r+=2*n,r},region:function(t,e,r){let n=4*t.vertexCount;return t["uv-region"]=new Uint16Array(e,r,n),r+=2*n,r}};function at(t,e,r,n){let o={vertexCount:0},a=new DataView(t);try{let i=0;if(o.vertexCount=a.getUint32(i,1),i+=4,o.featureCount=a.getUint32(i,1),i+=4,f(r))for(let e=0;e<r.attributes.length;e++)f(v[r.attributes[e]])?i=v[r.attributes[e]](o,t,i):console.error("Unknown decoder for",r.attributes[e]);else{let r=e.ordering,a=e.featureAttributeOrder;f(n)&&f(n.geometryData)&&f(n.geometryData[0])&&f(n.geometryData[0].params)&&(r=Object.keys(n.geometryData[0].params.vertexAttributes),a=Object.keys(n.geometryData[0].params.featureAttributes));for(let e=0;e<r.length;e++){let n=v[r[e]];i=n(o,t,i)}for(let e=0;e<a.length;e++){let r=v[a[e]];i=r(o,t,i)}}}catch(i){console.error(i)}return o.scale_x=1,o.scale_y=1,o}function lt(t){let e=it(t.binaryData,t.schema,t.bufferInfo,t.featureData);f(t.geoidDataList)&&t.geoidDataList.length>0&&nt(e.vertexCount,e.positions,e.scale_x,e.scale_y,t.cartographicCenter,t.geoidDataList,!1),rt(e.vertexCount,e.positions,e.normals,t.cartographicCenter,t.cartesianCenter,t.parentRotation,t.ellipsoidRadiiSquare,e.scale_x,e.scale_y),f(e.uv0s)&&f(e["uv-region"])&&ot(e.vertexCount,e.uv0s,e["uv-region"]);let r=st(e.vertexCount,e.indices,e.positions,e.normals,e.uv0s,e.colors),n={};if(f(e["feature-index"]))n.positions=e.positions,n.indices=e.indices,n.featureIndex=e["feature-index"],n.cartesianCenter=t.cartesianCenter,n.parentRotation=t.parentRotation;else if(f(e.faceRange)){n.positions=e.positions,n.indices=e.indices,n.sourceURL=t.url,n.cartesianCenter=t.cartesianCenter,n.parentRotation=t.parentRotation,n.featureIndex=new Array(e.positions.length);for(let t=0;t<e.faceRange.length-1;t+=2){let r=t/2,o=e.faceRange[t],a=e.faceRange[t+1];for(let t=o;t<=a;t++)n.featureIndex[3*t]=r,n.featureIndex[3*t+1]=r,n.featureIndex[3*t+2]=r}}return r._customAttributes=n,{meshData:r}}async function ft(t,e){let r=t.webAssemblyConfig;return q=f(r)&&f(r.wasmBinaryFile)?await(0,H.default)(r):await(0,H.default)(),!0}function yt(t,e){let r=t.webAssemblyConfig;return f(r)?ft(t,e):lt(t,e)}var gt=Z(yt);export{gt as default};